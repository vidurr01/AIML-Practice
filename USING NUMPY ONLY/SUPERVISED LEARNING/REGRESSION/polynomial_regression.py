# -*- coding: utf-8 -*-
"""Polynomial Regression

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ADhSV7W07RVYaCkEbEt6mQNkb7fT4TIz
"""

from sklearn.datasets import load_diabetes
from sklearn.preprocessing import StandardScaler

# Loading and diving into input and output
data = load_diabetes()
X, y = data.data, data.target

#Scaling for Gradient Descent to converge quickly.
scaler = StandardScaler()
X = scaler.fit_transform(X)

import numpy as np

interactions = []
for i in range(X.shape[1]):
    for j in range(i + 1, X.shape[1]):
        new_col = X[:, i] * X[:, j]
        interactions.append(new_col)

X_prod = np.column_stack(interactions) # mistake 1: had done np.hstack instead of np.column_stack
interactions2 = []
for i in range(X.shape[1]):
    for j in range(i + 1, X.shape[1]):
        new_col = X[:, i]/ (X[:, j]+1e-7)
        interactions2.append(new_col)
X_div = np.column_stack(interactions)
X2 = X**2
X_poly = np.hstack([X,X2,X_prod,X_div])
X_poly_mean = np.mean(X_poly, axis = 0)
X_poly_std = np.std(X_poly, axis = 0)
X_poly = (X_poly - X_poly_mean)/X_poly_std

# Splitting into train, test and validation data
from sklearn.model_selection import train_test_split
train_X,test_X,train_y,test_y = train_test_split(X_poly,y,test_size = 0.2, random_state = 0)
train_X,val_X,train_y,val_y = train_test_split(train_X,train_y,test_size = 0.2, random_state = 0)
print(train_X.shape, test_X.shape, val_X.shape, train_y.shape, test_y.shape, val_y.shape)

#train and validation phase
import numpy as np
w = np.zeros(train_X.shape[1],)
b = np.zeros(1,)
lr = 3e-3
J_best = 1e10
epochs = 1100
lambda1 = 1e-1
lambda2 = 1e-1
for epoch in range(epochs):
  # Train
  y = train_X@w + b
  J_train = np.mean((y-train_y)**2) + lambda1 * np.sum(np.absolute(w)) + lambda2* np.sum(w**2)
  dJdw = (1/train_X.shape[0])*(2*train_X.T@(y-train_y)) + lambda1 * np.sign(w) + 2*lambda2*w
  dJdb = np.mean(2*(y-train_y))
  w -= lr* dJdw
  b -= lr* dJdb
  # Validation
  y = val_X@w + b
  J_val = np.mean((y-val_y)**2) + lambda1 * np.sum(np.absolute(w))
  if (epoch+1)%100 == 0:
    print(f"{epoch+1}: train loss = {J_train}, validation loss = {J_val}")
  if J_val<J_best:
    J_best = J_val
    w_best = w.copy()
    b_best = b.copy()
print(f"Best validation loss = {J_best}")

#testing phase
y = test_X@w + b
J_test = np.mean((y-test_y)**2)
print(J_test)